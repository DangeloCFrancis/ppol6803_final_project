---
title: "Predicting Electoral Outcomes using Demographic Characterisitcs"
author: "D'Angelo Francis; Su Yeon Seo; Yuxiang 'Nathan' Su"
format: html
---


## Purpose

Our research project seeks to identify the key characteristics to identify and predict how a voter votes. 
 This project utilizes a Classification and Regression Tree model, and 'glm' (logistic and probit regression) models to predict the probability that a survey respondent voted 'conservatively' or 'liberally'[^1]. The primary data for analysis and modeling will be survey data from the [American National Election Studies](https://electionstudies.org/), a collaboration between Duke University,the University of Michigan,the University of Texas at Austin (UT Austin), Stanford University, and the National Science Foundation (NSF).  

For our model, we plan on using questions that the ANES asks about a candidate that voter voted for (*e.g., "Which candidate did you vote for in...?"*) as the outcome variable our model will predict. The goal of our models are to precisely predict which a voter voted for using the responses from survey questions asking about policies, such as transgender rights, gun control, reproductive rights, etc. We will incorporate a variable importance analysis to deduce which survey topics and demographic characteristics are the best indicators of voters' candidate preference.

## EDA

```{r}
#| label: exploratory data analysis 

library(tidyverse)
library(tidymodels) # use case weights 
library(readxl)
library(srvyr) # not needed
library(naniar)

anes_1948_2020 <- 
  read_csv("data/anes_timeseries_cdf_csv_20220916.csv")

# tidying, getting years to 2000 - 2020 and pre-election vs post-election

# VCF9999 Version Number Of Release Weight post-election weight full sample - is it ok to drop obs with missing weight?

# need to filter for voters (get rid of nonvoter observations)


# Keep VCF0004 (year), VCF9999 (post election weight), VCF0013 and VCF0014 (post and pre election completion indicator), and VCF0748 (voted on election day or not)

anes_2000_2020 <- 
  anes_1948_2020 |>
  select(
    VCF0004,VCF9999,VCF0013,VCF0014,VCF0101,VCF0104,VCF0105b,VCF0110,VCF0128,
    VCF0147,VCF0111,VCF0114,VCF0116,VCF0151,VCF0146,VCF9224,VCF0801, VCF0803,
    VCF0805,VCF0806, VCF0811, VCF0813,VCF0814,VCF0823,VCF0824,VCF0826,
    VCF0894,VCF0829, VCF9279,VCF9280,VCF0201:VCF0236, VCF0253, VCF0290, 
    VCF0291,VCF0230,VCF9223,VCF0302,VCF0748,VCF0307,
    VCF0308,VCF0338,VCF0705,VCF0706,VCF0900, VCF0601,VCF0604,VCF0605,VCF0606,
    VCF0607,VCF0608,VCF0609,VCF0610,VCF0611,VCF0612,VCF0613,VCF0614,VCF0704,
    VCF0704a,VCF0301,VCF0906,VCF0907
  ) |>
  filter(VCF0004 %in% c(2000:2020), 
         VCF0014 == 1 & VCF0013 == 1, 
         is.na(VCF9999) == FALSE,
         VCF0748 %in% c(1,5)
         ) |> 
  add_n_miss() |>
  select(-where(~sum(is.na(.)) > 1000))

# Check of NAs in each var by column

na_count <-
  as_tibble(colSums(is.na(anes_2000_2020)))

# Imputations Needed / Check for relationships 

# VCF0114 - Respondent Family - Income Group
# VCF0806 - GOVERNMENT HEALTH INSURANCE SCALE
# VCF0218 - THERMOMETER - DEMOCRATIC PARTY
# VCF0224 - THERMOMETER - REPUBLICAN PARTY
# VCF0290 - THERMOMETER AVERAGE - MAJOR PARTIES
# VCF0291 - THERMOMETER INDEX - MAJOR PARTIES
# VCF0705 - VOTE FOR PRESIDENT- MAJOR PARTIES AND OTHER
# VCF0706 - VOTE AND NONVOTE- PRESIDENT

anes_2000_2020_nab <- 
  anes_2000_2020 |> 
  nabular()

# dropping outcome vars, dealing with NAs (or attempting to) - where is the function that I am trying to subset?

anes_2000_2020_model <- 
  anes_2000_2020 |>
  select(-c(VCF0704,VCF0704a, VCF0705, VCF0706, VCF0301,VCF0906,VCF0907,n_miss_all)) |> # dropping outcome vars
  mutate(across(c(VCF0101:VCF0613),impute_median(where(is.na))))


anes_2000_2020_model <- 
  anes_2000_2020 |>
  select(-c(VCF0704,VCF0704a, VCF0705, VCF0301,VCF0906,VCF0907,n_miss_all))


anes_2000_2020_model$VCF0706 <- as.character(anes_2000_2020_model$VCF0706)

anes_2000_2020_model$VCF0706 <- fct(anes_2000_2020_model$VCF0706)
```


```{r}
#|label: model-building

set.seed(8)

anes_split <- initial_split(anes_2000_2020_model)

anes_training <- training(anes_split)

anes_testing <- testing(anes_split)

# Deal with missing in training data 

# Q: impute before or after split? What's our method of imputation? 

voter_weight <- 
  anes_training |>
  importance_weights(VCF9999)


anes_recipe <- 
  anes_training |>
  recipe(formula = VCF0706~.) |>
  add_case_weights()
  step_select(-c(VCF0004, VCF9999)) |>
  step_impute_bag(all_predictors()) |>
  step_normalize(all_numeric_predictors())

anes_model <-
  nearest_neighbor(
    mode = "classification",
    engine = "kknn"
  )

anes_workflow <- 
  workflow() |>
  add_recipe(anes_recipe) |>
  add_model(anes_model)

prep(anes_recipe)

anes_fit <- 
  anes_workflow |>
  fit(data = anes_training)
  
anes_fit

```